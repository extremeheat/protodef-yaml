# protodef-yaml
[![NPM version](https://img.shields.io/npm/v/protodef-yaml.svg)](http://npmjs.com/package/protodef-yaml)
[![Build Status](https://github.com/extremeheat/protodef-yaml/workflows/CI/badge.svg)](https://github.com/extremeheat/protodef-yaml/actions?query=workflow%3A%22CI%22)
[![Discord](https://img.shields.io/badge/chat-on%20discord-brightgreen.svg)](https://discord.gg/GsEFRM8)
[![Try it on gitpod](https://img.shields.io/badge/try-on%20gitpod-brightgreen.svg)](https://gitpod.io/#https://github.com/extremeheat/protodef-yaml)

Transforms a YAML-like syntax to a ProtoDef JSON schema and can also generate HTML documentation. This tool simplifies the creation and maintenance of complex protocol definitions.

[See a live demo of the editor!](https://extremeheat.github.io/protodef-yaml/editor/)

## Transformation Overview

`protodef-yaml` processes input files in several stages:

1.  **Preprocessing (`toYAML`)**: The input YAML-like text is parsed. During this stage:
    *   `!import` directives are resolved, and the content of imported files is merged.
    *   Shorthand syntax (like `type[]` for arrays, `key => type` for mappers, `switch?` for switches) is expanded into an intermediate YAML representation using special `%` prefixes (e.g., `%array`, `%map`, `%switch`).
    *   Comments can be optionally converted into `!comment` nodes for documentation generation.
    *   Other `!` prefixed keys are marked to be handled by specific plugins or ignored in the final schema.
2.  **Parsing (`parseYAML`)**: The processed YAML string (or strings, if imports were used) is parsed into a JavaScript object using a standard YAML parser. This object is an intermediate representation.
3.  **Transformation (`transform`)**: This stage converts the intermediate JavaScript object into the final ProtoDef JSON schema structure. It interprets the `%` prefixed keys and other conventions:
    *   `%container` creates a `["container", [members...]]` structure.
    *   `%array` creates an `["array", {countType, type, count}]` structure.
    *   `%map` creates a `["mapper", {type, mappings}]` structure.
    *   `%switch` creates a `["switch", {compareTo, fields, default}]` structure.
    *   Field names ending with `?` (e.g., `myField?: string`) are converted into `["option", type]`.
    *   Anonymous fields denoted by `_:` are transformed with an `anon: true` property.
4.  **Structuring (`applyStructuringTf`)**: Optionally, if the input YAML uses `^` prefix in keys (e.g., `^path.to.type`), this stage restructures the flat schema into a nested one. For example, `^foo.bar: type` would result in `{ "foo": { "bar": type } }`.
5.  **Output**: The resulting ProtoDef JSON schema can be written to a file or returned as an object. HTML documentation can also be generated from the intermediate representation.

## Usage

```sh
npm install -g protodef-yaml
protodef-yaml <input yaml file> <output json file> # generate json
protodef-yaml <input yaml file> <output html file> # generate docs
```

or through npx,
```
npx protodef-yaml input.yml
npx protodef-yaml input.yml docs.html
```

### API

See [API.md](./API.md) for detailed API documentation.

## Syntax

`protodef-yaml` uses a YAML-like syntax with several special features to define protocol schemas efficiently.

### Key Concepts and Special Prefixes

1.  **`!` Prefix (Directives and Ignored Keys)**:
    *   Keys starting with `!` are treated as directives or are ignored in the final JSON output unless a plugin handles them.
    *   **`!import path/to/another.yml`**: Imports another YAML file. The content of the imported file is processed as if it were part of the original file. Paths are relative to the current file.
    *   **`!StartDocs` / `!EndDocs`**: These directives can be used to mark sections of the YAML that are specifically for documentation generation. Comments within these blocks can be converted to `!comment` entries.
    *   **`!comment: "My comment"`**: When documentation generation is active, regular YAML comments (`# this is a comment`) can be transformed into these nodes.
    *   Other `!key: value` pairs are generally ignored by the core transformer but can be used by custom plugins or for metadata.

2.  **`%` Prefix (Complex Type Definitions)**:
    *   The `%` prefix is used in keys to define complex ProtoDef types beyond simple key-value pairs. This is part of the intermediate representation generated by `toYAML` from shorthand syntax, but can also be used directly.
    *   **`"%container,name": { members... }`**: Defines a container type.
        *   Example Shorthand:
            ```yaml
            my_container:
              field1: string
              field2: i32
            ```
            This implicitly becomes a container.
    *   **`"%array,name,type,countType": { element_definition }`**: Defines an array.
        *   `name`: The name of the array field.
        *   `type` (optional): The type of elements if they are simple (e.g., `string`, `i32`).
        *   `countType` (optional): The type of the field that specifies the count of elements (e.g., `varint`, `u8`). If prefixed with `$`, it's a direct count value (e.g., `$5`).
        *   The body defines the structure of array elements if they are complex (e.g., a container).
        *   Example Shorthand:
            ```yaml
            my_array[]: # simple array of implicit containers
              element_field1: string
            my_typed_array[]varint: string # array of strings, count is varint
            fixed_array[]$5: u8 # array of 5 u8s
            ```
    *   **`"%map,name,mappingType": { mappings... }`** or **`"%map,name,sizeType,valueType": {}`**: Defines a mapper.
        *   `name`: The name of the mapper field.
        *   `mappingType` (or `sizeType`): The data type of the value being mapped from.
        *   `valueType` (optional, if mappings are inline): The data type of the value being mapped to, if not defining inline mappings.
        *   The body contains the key-value mappings.
        *   Example Shorthand:
            ```yaml
            my_mapper: u8 =>
              0: type_a
              1: type_b
            another_mapper: u8 => string # maps u8 to string types (less common)
            ```
    *   **`"%switch,name,compareTo": { fields... }`**: Defines a switch type.
        *   `name`: The name of the switch field.
        *   `compareTo`: The path (relative or absolute) to the field whose value determines the case.
        *   The body contains cases, where keys are values of `compareTo` and values are the corresponding types. `default` can be used for a default case.
        *   Example Shorthand:
            ```yaml
            type_selector: u8
            data_based_on_type: type_selector? # compareTo is 'type_selector'
              case_0:
                field_a: string
              case_1:
                field_b: i32
              default: void
            ```

3.  **`_` (Anonymous Fields)**:
    *   A key of `_` (underscore) defines an anonymous field. This is useful in switches or containers where a field doesn't need a name in the final structure but is syntactically required or aids in organization.
    *   The transformer will mark such fields with `anon: true`.
    *   Example:
        ```yaml
        packet_type: u8
        payload: packet_type?
          0: # switch case
            _: # anonymous container
              field1: string
              field2: i32
          1:
            data: u8array
        ```

4.  **`?` Suffix (Optional Fields)**:
    *   Appending `?` to a field name makes that field optional. The transformer wraps its type in `["option", type]`.
    *   Example:
        ```yaml
        config:
          required_setting: string
          optional_setting?: i32
        ```
        Here, `optional_setting` becomes `["option", "i32"]`.

5.  **`^` Prefix (Structuring/Nesting)**:
    *   The `^` prefix on a key is used to restructure the output JSON, creating nested objects.
    *   A key like `^path.to.mytype: definition` will result in a schema where `definition` is placed at `jsonOutput.path.to.mytype`.
    *   This is processed in the `applyStructuringTf` stage, after the main transformation.
    *   Example:
        ```yaml
        ^common.types.identifier: string
        ^common.types.timestamp: i64
        packet:
          id: ^common.types.identifier
          time: ^common.types.timestamp
          payload: u8array
        ```
        Output (conceptual, after structuring):
        ```json
        {
          "common": {
            "types": {
              "identifier": "string",
              "timestamp": "i64"
            }
          },
          "packet": { // Assuming 'packet' itself isn't prefixed with ^
            "id": "string", // Actual type, not the reference string
            "time": "i64",  // Actual type
            "payload": "u8array"
          }
        }
        ```
        **Note**: If `packet` was defined as `^mypackages.packet`, it would also be nested. The example above shows how to define types in a "common" namespace and then reference them (though direct referencing by the string `^common.types.identifier` in the `packet` definition is illustrative; typically the types are defined and then used by their final path if nesting is applied globally). The primary use of `^` is to organize the final JSON structure of defined types, not for direct cross-referencing in the YAML by that exact `^` path during parsing.

### Main Example

Consider the following input (`input.yml`):
```yaml
# Define a common type using caret for namespacing
^myprotocol.common.timestamp: i64

# Main packet definition
ScoreEntries:
  # type is a mapper, u8 maps to 'change' or 'remove'
  type: u8 =>
    0: change
    1: remove
  # entries is an array, counted by a varint
  entries: []varint
    scoreboard_id: zigzag64
    objective_name: string
    score: li32
    # optional_info is an optional boolean field
    optional_info?: bool
    # _ introduces an anonymous switch, comparing against the 'type' field (../type)
    _: ../type?
      # if type is 'remove', this structure applies
      remove:
        entry_type: i8 => # mapper for entry_type
          1: player
          2: entity
          3: fake_player
        # another anonymous switch, based on the entry_type
        _: entry_type?
          player or entity: # combined case for player or entity
            entity_unique_id: zigzag64
          fake_player:
            custom_name: string
      # default case for the outer switch (if type is not 'remove')
      default: void
  # Use the namespaced timestamp
  created_at: ^myprotocol.common.timestamp
```

This will be transformed into the following ProtoDef JSON:

**Output JSON**
<details>
<summary>Click to expand</summary>

```json
```json
{
  "myprotocol": {
    "common": {
      "timestamp": "i64"
    }
  },
  "ScoreEntries": [
    "container",
    [
      {
        "name": "type",
        "type": [
          "mapper",
          {
            "type": "u8",
            "mappings": {
              "0": "change",
              "1": "remove"
            }
          }
        ]
      },
      {
        "name": "entries",
        "type": [
          "array",
          {
            "countType": "varint",
            "type": [
              "container",
              [
                {
                  "name": "scoreboard_id",
                  "type": "zigzag64"
                },
                {
                  "name": "objective_name",
                  "type": "string"
                },
                {
                  "name": "score",
                  "type": "li32"
                },
                {
                  "name": "optional_info",
                  "type": [
                    "option",
                    "bool"
                  ]
                },
                {
                  "anon": true,
                  "type": [
                    "switch",
                    {
                      "compareTo": "../type",
                      "fields": {
                        "remove": [
                          "container",
                          [
                            {
                              "name": "entry_type",
                              "type": [
                                "mapper",
                                {
                                  "type": "i8",
                                  "mappings": {
                                    "1": "player",
                                    "2": "entity",
                                    "3": "fake_player"
                                  }
                                }
                              ]
                            },
                            {
                              "anon": true,
                              "type": [
                                "switch",
                                {
                                  "compareTo": "entry_type",
                                  "fields": {
                                    "player": [
                                      "container",
                                      [
                                        {
                                          "name": "entity_unique_id",
                                          "type": "zigzag64"
                                        }
                                      ]
                                    ],
                                    "entity": [
                                      "container",
                                      [
                                        {
                                          "name": "entity_unique_id",
                                          "type": "zigzag64"
                                        }
                                      ]
                                    ],
                                    "fake_player": [
                                      "container",
                                      [
                                        {
                                          "name": "custom_name",
                                          "type": "string"
                                        }
                                      ]
                                    ]
                                  },
                                  "default": "void"
                                }
                              ]
                            }
                          ]
                        ]
                      },
                      "default": "void"
                    }
                  ]
                }
              ]
            ]
          }
        ]
      },
      {
        "name": "created_at",
        "type": "i64"
      }
    ]
  ]
}
```
</details>

### Additional Notes

*   **YAML Superset**: Standard YAML features are supported. You can embed JSON directly within your YAML for complex, predefined ProtoDef types if needed, as YAML is a superset of JSON.
    ```yaml
    custom_string_type: ["pstring", {"countType": "i32"}]
    ```
*   **Parent Node Values**: Unlike standard YAML in some interpretations, a node that has child nodes (acting as a container or other complex type) can also have a value associated with its own line, typically used for defining the type or parameters of the structure (e.g., `my_array[]varint: string`).


This enhanced documentation provides a more comprehensive guide to using `protodef-yaml`.

```yaml
string: ["pstring", {"countType": "i32"}]
```
